<!DOCTYPE html>
<head> 
<meta charset="utf-8">
<style>
  body {
    width:700px;
    margin:auto;
    
  }
  .countries {
    fill:#444;  
  }
  
  .borders {
    stroke:white;
    fill:none;
  }
</style>

</head>
<body>
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script>

var width = 700,
    height = 700;

var projection = d3.geoOrthographic()
    .scale(220)
    .translate([width / 2, height / 2])
    .clipAngle(90)
    .rotate([-100.4,-30]);

var path = d3.geoPath()
    .projection(projection);

var λ = d3.scaleLinear()
    .domain([0, width])
    .range([-180, 180]);

var φ = d3.scaleLinear()
    .domain([0, height])
    .range([90, -90]);

var svg = d3.select("body").append("div")
            .style("background-color","#EEE")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            ;
            


/*
svg.on("mousemove", function() {
  var p = d3.mouse(this);
  projection.rotate([λ(p[0]), φ(p[1])]);
  svg.selectAll("path").attr("d", path);
});
*/
let rotate0, coords0;
let moving = true;

let coords = () => projection.rotate(rotate0)
          .invert([d3.event.x, d3.event.y]);
          
// regist a empty rect to receive drag vehavior



d3.json("./data/world-110m.json", function(error, world) {
  if (error) throw error;
  countries = topojson.feature(world, world.objects.countries).features;
  svg.selectAll(".countries")
      .data(countries)
      .enter().append("path")
      .attr("class", "countries")
      .attr("d", path)
      .on("mouseover",function(){
        d3.select(this).style("fill","red"); 
        })
      .on("mouseout",function(){
        d3.select(this).style("fill","#444");
      })
      .on("click",function(d){
        
       (function transition() {
              d3.select(this).transition()
              .duration(750)
              .tween("rotate", function() {
                var p = d3.geoCentroid(d),
                    r = d3.interpolate(projection.rotate(), [-p[0], -p[1]]);
                return function (t) {
                  projection.rotate(r(t));
                  svg.selectAll("path").attr("d", path);
                }
              });
            })();
       })
        .call(d3.drag()
           .on('start', () => {           
              rotate0 = projection.rotate();
              coords0 = coords();
              moving = true;
              
            })
            .on('drag', () => {
              const coords1 = coords();
              projection.rotate([
                rotate0[0] + coords1[0] - coords0[0],
                rotate0[1] + coords1[1] - coords0[1],
              ])
              d3.selectAll("path").attr("d",path); 
            })
            .on('end', () => {
              moving = false;
            })
        );

      
 svg.append("path")
    .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
    .attr("class", "borders")
    .attr("d", path);    
 
      
});

</script>
